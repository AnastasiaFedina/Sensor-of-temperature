//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define F_CPU 9216000L // Частота мікроконтролера
#define BAUD 9600 // Швидкість передачі
#define UBRRcalc (F_CPU/(BAUD*16L)-1)
#define BUF_SIZE 16 // Розмір буфера1 
#define BUF_MASK (BUF_SIZE-1)
#define BUF1_SIZE 16 // Розмір буфера2
#define BUF1_MASK (BUF1_SIZE-1)
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <avr/io.h>
#include <util/delay.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <math.h> 
#include <stdlib.h> 
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
unsigned char BufOut[BUF_SIZE], StartBufOut = 0, EndBufOut = 0; // Буфер1
unsigned char Buf1Out[BUF_SIZE], StartBuf1Out = 0, EndBuf1Out = 0; // Буфер2
volatile unsigned char  WaitRead = 0, WaitWrite = 0; 
unsigned char Number = 0;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ISR(USART0_RX_vect) // Переривання при прийнятому байті на USART0
{ 
	unsigned char Temporary=UDR0;
	WriteBufOut(Temporary); // записуємо значення адреси у буфер1
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void WriteBufOut(unsigned char value) // Запис у буфер1
{
	BufOut[EndBufOut++] = value;
    EndBufOut &= BUF_MASK;
    cli();
    if(WaitRead == 0) UCSR1B |= 1<<UDRIE1; // Дозвіл на переривання при спорожненні UDR1
    sei();
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ISR(USART1_UDRE_vect) // Переривання при спорожненні UDR1
{
	PORTD |= 1<<PD4; // Переходимо у режим передачі
    UCSR1B |= 1<<TXB81; // Переходимо у восьми бітний редим        
    asm("nop");
    UDR1 = BufOut[StartBufOut++]; // Передаємо начення буфера у UDR1
    StartBufOut &= BUF_MASK;
    if(StartBufOut == EndBufOut || WaitRead == 1) UCSR1B &= ~(1<<UDRIE1); // При спорожненні буферу1 забороняємо переривання при спорожненні UDR1
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ISR(USART1_TX_vect) // Переривання при відправленому байті USART1
{ PORTD &= ~(1<<PD4); } // Перехід у режим прийому
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ISR(USART1_RX_vect) // Переривання при прийнятому байті USART1               
{ 
	unsigned char One;
	One = UDR1;
	WriteBuf1Out(One); // Записуємо значення UDR1 в буфер2
	Number++;
	if (Number == 4) // якщо ми прийняли 4 байти
	{
		Number = 0;
	    WaitRead = 0;
	    if(StartBufOut != EndBufOut) UCSR1B |= 1<<UDRIE1; // Якщо буфер1 не порожній, то дозволити переривання при спорожненні UDR1
	}	
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void WriteBuf1Out(unsigned char value) // Запис у буфер2
{
	Buf1Out[EndBuf1Out++] = value;
    EndBuf1Out &= BUF1_MASK;
    cli();
    if(WaitWrite == 0) UCSR0B |= 1<<UDRIE0; // Дозвіл на переривання при спорожненні UDR0
    sei();
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ISR(USART0_UDRE_vect) // Переривання при спорожненні UDR0              
{                                                          
    UDR0 = Buf1Out[StartBuf1Out++]; // Передаємо значення з буферу2
	WaitWrite = 1;
    StartBuf1Out &= BUF1_MASK;
    if(StartBuf1Out == EndBuf1Out  ||  WaitWrite == 1) UCSR0B &= ~(1<<UDRIE0); // Якщо буфер2 порожній, то забороняємо переривання при спорожненні UDR0
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ISR(USART0_TX_vect) // Переривання при відправленному байті USART0                  
{ WaitWrite = 0; } 
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
int main()
{
	cli();
	Init(); // Ініціалізація заліза
	_delay_ms(3000);
    sei();  
	while(1)
	{	}
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Init()      
{
	DDRA  = 0xFF; // Ініціалізація портів
	PORTA = 0x00;
	DDRB  = 0xFF;
	PORTB = 0x00;
	DDRC  = 0xFF;
	PORTC = 0x00;
    DDRD=0b11111010; 
	PORTD=0b00000101;
    UBRR1L = (unsigned char)(UBRRcalc); // Ініціалізація USART1
    UBRR1H = (unsigned char)(UBRRcalc>>8); // Швидкість передачі
    UCSR1A = 0; // Обнулення UCSR1A
    UCSR1C = (1<<UCSZ11) | (1<<UCSZ10) | (1<<USBS1); // Формат кадру 9n2 без перевірки парності
    UCSR1B = (1<<UCSZ12) | (1<<RXEN1) | (1<<TXEN1) | (1<<RXCIE1) | (1<<TXCIE1); // Дозвіл прийому-передачі+перерив.прийому,заверш.перед.+9n
	UBRR0L = (unsigned char)(UBRRcalc); // Ініціалізація USART0
    UBRR0H = (unsigned char)(UBRRcalc>>8); // Швидкість передачі
	UCSR0A=0; // Обнулення UCSR0A
	UCSR0B=(1<<RXCIE0) | (1<<TXCIE0) | (1<<RXEN0) | (1<<TXEN0); // Дозвіл прийому-передачі+перерив.прийому,заверш.перед.
 	UCSR0C=(1<<UCSZ01) | (1<<UCSZ00); // Формат кадру 8n1 без перевірки парності
}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
